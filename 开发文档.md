# 在RT-Thread Smart上支持rust语言编写的用户态程序

## 一、项目概述

### 1.1 项目背景

嵌入式平台广泛应用于各类电子设备中，其核心需求之一是能够高效地执行特定任务。这些平台通常具有资源受限的特点，包括有限的处理能力、存储空间和电源供应。因此，实时操作系统（RTOS）成为嵌入式系统的关键组件，它能够提供确定性、高可靠性和低延迟的任务调度和资源管理。

RT-Thread Smart（简称rt-smart）是RT-Thread开源实时操作系统的一个扩展版本，专为嵌入式平台设计。它继承了RT-Thread的核心特性，如高实时性、模块化和灵活性，同时增强了用户态应用程序的支持，使其能够运行复杂的用户态任务。

目前，RT-Thread Smart的用户态应用程序主要支持C/C++语言，并使用musl libc作为其标准库。C/C++语言在嵌入式系统中有着深厚的历史积淀，丰富的库和工具链使其在嵌入式开发中占据重要地位。然而，随着嵌入式系统的复杂性增加，以及对安全性和开发效率的更高要求，C/C++的某些局限性逐渐显现，如手动内存管理的复杂性和潜在的安全漏洞。

#### Rust语言的优势

Rust语言自诞生以来，迅速崭露头角，特别是在系统编程领域。其核心特点包括：

1. **内存安全**：Rust通过所有权系统和借用检查器，确保在编译时避免空指针、悬垂指针和数据竞争等常见的内存安全问题。
2. **高性能**：Rust编译后的程序能够接近甚至达到C/C++的性能，这对于资源受限的嵌入式系统尤为重要。
3. **并发性**：Rust提供了安全且高效的并发编程模型，使得开发者能够充分利用多核处理器的能力，而不必担心并发带来的复杂性和安全问题。
4. **现代化开发体验**：Rust拥有强大的包管理器（Cargo），现代化的语法和工具链，极大地提升了开发者的生产力和代码质量。

将Rust语言引入RT-Thread Smart，不仅能够丰富其用户态应用程序的开发语言选择，还能为嵌入式开发带来诸多优势，如Rust的内存安全特性可以减少因内存错误导致的系统崩溃和安全漏洞。Rust的现代化语法和工具链能够加速开发流程，减少调试和维护时间等。

### 1.2 预期目标

1. Rust语言支持库（已完成）

   编译并运行rt-smart操作系统。编译一个最小的Rust语言程序，使之能在rt-smart操作系统上运行；查阅rt-smart的文档和资料，了解其中可用的系统调用。查阅rt-smart与编译器有关的文档，了解rt-smart遵守的调用约定；选择一个系统调用的模块，制作一个封装和处理这部分系统调用的库。依赖于这个库，用户可以编写应用于rt-smart操作系统的应用程序，并使用里面的系统调用。请参考libtock-rs。

2. 制作一个到rt-smart的Rust编译目标（已完成）

   查阅Rust语言相关的资料，了解Rust语言目前支持哪些平台。Rust语言是否拥有面向嵌入式操作系统专门的编译目标？请举例；作为一个独立的平台，rt-smart提供平台相关的开发方法。请为Rust编译器添加一个名为“aarch64-rt-smart”的编译目标。使用该目标得到的二进制程序，能直接应用到rt-smart支持的平台上；请将第一题的成果视作标准库的一部分，选择一个系统调用的模块，为`aarch64-rt-smart`添加std标准库对应模块的代码。

3. Rust生态中的rt-smart平台（已完成）

   许多的库实现和平台有关系，这些库通常需要特定的操作系统功能支持。比如`num_cpus`，它在不同平台上调用不同的系统调用，达到列出CPU核数量的功能。查阅资料，列出几个这样的库。[您可能需要浏览crates.io或lib.rs](http://xn--crates-2b6jp45f6hzoe5bfutnya307j.xn--iolib-ym6j.rs/)。选择一个Rust生态中的库，为其添加代码，使之能支持rt-smart操作系统的相关功能。

### 1.3 项目达成的目标

1. 通过封装 `aarch64-smart-museabi` 上的C库函数，基于Rust的FFI机制（Foreign Function Interface，外部函数接口），封装成Rust程序能够调用的接口，再通过静态库链接的方式将库函数链接到最终的应用程序中，保证函数能够被正确调用，从而使得Rust应用程序能够调用 `rtsmart` 操作系统提供的系统功能，为封装Rust功能库提供依赖
2. 通过修改Rust编译器中对于编译平台的支持，添加一个到 `aarch64-unknown-rtsmart` 的编译目标，提供如 `llvm_target`、`linker`、`max_atomic_width`、`pointer_width`、`data_layout`、`arch`等 `aarch64-unknown-rtsmart` 架构和系统有关的target option，使得Rust编译器能够i编译出适配当前架构与系统的机器指令，使得应用程序能够在目标平台上运行
3. 基于目标1封装的libc库，编写Rust生态中常用的标准库函数。即为Rust编写一个针对 `aarch64-unknown-rtsmart` 平台的标准库，使得用户能够调用标准库的函数编写更加复杂的应用程序。当前项目编写的主要标准库包括：用于标准输出的`stdout`库，用于标准输入的`stdin`库，用于创建、运行、操作、删除线程的`thread`库，用于保障线程安全的`mutex`库，用于创建文件、操作文件读写的`fs`库

### 1.3 项目目录结构

代码和文档都存储Gitlab仓库中。以下是仓库目录和文件描述：

```plaintext
.project2210132-226009/						
│   README.md				//项目说明文件
│   README.pdf				//项目说明文件PDF版本
│   技术文档.md				 //技术文档
│   技术文档.pdf			 //技术文档PDF版本
├─ img/                     //技术文档图片
├─ examples/                //标准库测试程序
│	├── example1/hello		//libc和rust编译目标的测试，最小的Rust语言程序
│	├── example2/hello		//测试marco_main属性宏和stdout库的测试程序
│	├── example3/thread_test//测试thread库的测试程序
│	├── example4/mutex_test //测试mutex库的测试程序
│	├── example5/read_test  //测试stdin库的测试程序
│	└── example6/file_test  //测试fs库的测试程序
├─ libc/					//Rust在不同系统平台的外部函数接口
├─ marco_main/				//将Rust风格的main函数转换为C风格的main函数的属性宏
├─ rtsmart-std/				//基于libc开发的rtsmart平台上的标准库
│	├── src/				//源代码
│		├── api/			//封装调用libc的api
│		├── prelude/		//预引入的库
│		│   fs.rs			//fs库
│		│   lib.rs			//模块声明
│		│   malloc.rs		//内存分配器
│		│   mutex.rs		//mutex库
│		│   put.rs			//stdout库的辅助模块
│		│   stdin.rs		//stdin库
│		│   stdout.rs		//stdout库
│		│   thread.rs		//thread库
│		└── time.rs			//time库
├─ rust/					//为添加编译目标，在rust编译器源代码中修改或添加的文件
└─ worklog/					//每周的工作日志
```

## 二、赛题分析与调研

根据预期目标可知，本项目的主要任务分为三个部分，分别是封装Rust在rt-smart系统平台上的外部函数接口库`libc`、向Rust编译器添加一个到`aarch64-unknown-rtsmart`平台的编译目标、编写rt-smart平台上的Rust标准库

### 1. 外部函数接口库`libc`

该库是基于Rust的`FFI`功能实现的，`FFI`全称是 `Foregn Function Interface` ，即实现不同编程语言间的函数级相互调用，对于复杂的项目，可以充分复用不同编程语言的已有功能，减小开发负担。`Rust` 语言作为一种新时代的系统级编程语言，它同 `C/C++` 一样都是直接将程序代码编译为机器指令码执行，相比 `Java,Python` 等底层使用虚拟机解释执行字节码及使用垃圾回收的语言，在实现 `FFI` 时容易得多。利用 `C/C++` 的已有的生态基础，`Rust` 很多底层代码不用重复造轮子，直接通过 `FFI` 封装复用已有的 `C/C++` 库，这对于一门新语言能快速广泛的运用到项目中是至关重要的。

Rust 调用 C 的情况，我们需要在 Rust 中声明需要调用的 C 函数，这样 Rust 在编译生成调用符号及调用规范时，便会采用 C 的规范去编译。Rust 中也是采用 `extern "C"` 的方式去声明 C 的调用接口，不过 Rust 并不知道实际 C 函数的实现是否安全，所以一般在申明前加上 `unsafe` 关键字（非必须，但是C函数调用必须处于 `unsafe` 块中）。 示例如下：

```rust
use libc::c_int;

#[link(name = "add")]
unsafe extern "C" {
    fn add(c_int, c_int) -> c_int;
}

fn main() {
    let a: i32 = 10;
    let b: i32 = 20;
    let c: i32 = unsafe { add(a, b) };
}
```

不像 C 和 C++ 都可以使用支持 C++ 的编译器进行编译，Rust 和 C 需要使用各自不同的编译器进行编译，最后在链接起来。Rust 调用 C 通常是先将 C 代码编译为静态库文件，然后在构建 Rust 程序时，在链接阶段链接到 C 静态库。

我们可以在声明代码块前加上特定的 rust 属性宏 `#[link(name = "add")]` 去指导编译器链接到某个具体的静态库。

如此，我们的`libc`库的作用就是将这些C库函数引入并链接到Rust应用程序中来，使得我们的Rust应用程序能够调用这些C库函数

### 2. Rust编译目标

Rust编译器对不同平台的支持由编译器下的compiler/rust_target来定义，用于告知编译器应生成何种输出，以下是编译器支持的部分编译目标：

```rust
supported_targets! {
    ("x86_64-unknown-linux-gnu", x86_64_unknown_linux_gnu),
    ("x86_64-unknown-linux-gnux32", x86_64_unknown_linux_gnux32),
    ("i686-unknown-linux-gnu", i686_unknown_linux_gnu),
    ("i586-unknown-linux-gnu", i586_unknown_linux_gnu),
    ("loongarch64-unknown-linux-gnu", loongarch64_unknown_linux_gnu),
    ("loongarch64-unknown-linux-musl", loongarch64_unknown_linux_musl),
    ("m68k-unknown-linux-gnu", m68k_unknown_linux_gnu),
    ("csky-unknown-linux-gnuabiv2", csky_unknown_linux_gnuabiv2),
    ("csky-unknown-linux-gnuabiv2hf", csky_unknown_linux_gnuabiv2hf),
    ("mips-unknown-linux-gnu", mips_unknown_linux_gnu),
    ("mips64-unknown-linux-gnuabi64", mips64_unknown_linux_gnuabi64),
    ("mips64el-unknown-linux-gnuabi64", mips64el_unknown_linux_gnuabi64),
    ("mipsisa32r6-unknown-linux-gnu", mipsisa32r6_unknown_linux_gnu),
    ("mipsisa32r6el-unknown-linux-gnu", mipsisa32r6el_unknown_linux_gnu),
    ("mipsisa64r6-unknown-linux-gnuabi64", mipsisa64r6_unknown_linux_gnuabi64),
    ("mipsisa64r6el-unknown-linux-gnuabi64", mipsisa64r6el_unknown_linux_gnuabi64),
    ("mipsel-unknown-linux-gnu", mipsel_unknown_linux_gnu),
    ("powerpc-unknown-linux-gnu", powerpc_unknown_linux_gnu),
    ("powerpc-unknown-linux-gnuspe", powerpc_unknown_linux_gnuspe),
    ("powerpc-unknown-linux-musl", powerpc_unknown_linux_musl),
    ("powerpc64-ibm-aix", powerpc64_ibm_aix),
    ("powerpc64-unknown-linux-gnu", powerpc64_unknown_linux_gnu),
    ("powerpc64-unknown-linux-musl", powerpc64_unknown_linux_musl),
    ("powerpc64le-unknown-linux-gnu", powerpc64le_unknown_linux_gnu),
    ("powerpc64le-unknown-linux-musl", powerpc64le_unknown_linux_musl),
    ("s390x-unknown-linux-gnu", s390x_unknown_linux_gnu),
    ("s390x-unknown-linux-musl", s390x_unknown_linux_musl),
    ("sparc-unknown-linux-gnu", sparc_unknown_linux_gnu),
    ("sparc64-unknown-linux-gnu", sparc64_unknown_linux_gnu),
    ("arm-unknown-linux-gnueabi", arm_unknown_linux_gnueabi),
    ("arm-unknown-linux-gnueabihf", arm_unknown_linux_gnueabihf),
    ("armeb-unknown-linux-gnueabi", armeb_unknown_linux_gnueabi),
    ("arm-unknown-linux-musleabi", arm_unknown_linux_musleabi),
    ("arm-unknown-linux-musleabihf", arm_unknown_linux_musleabihf),
    ("armv4t-unknown-linux-gnueabi", armv4t_unknown_linux_gnueabi),
    ("armv5te-unknown-linux-gnueabi", armv5te_unknown_linux_gnueabi),
    ("armv5te-unknown-linux-musleabi", armv5te_unknown_linux_musleabi),
    ("armv5te-unknown-linux-uclibceabi", armv5te_unknown_linux_uclibceabi),
    ("aarch64-unknown-linux-musl", aarch64_unknown_linux_musl),
    ("x86_64-unknown-linux-musl", x86_64_unknown_linux_musl),
    ("i686-unknown-linux-musl", i686_unknown_linux_musl),
    ("i586-unknown-linux-musl", i586_unknown_linux_musl),
    ("mips-unknown-linux-musl", mips_unknown_linux_musl),
    ("mipsel-unknown-linux-musl", mipsel_unknown_linux_musl),
    ("mips64-unknown-linux-muslabi64", mips64_unknown_linux_muslabi64),
    ("mips64el-unknown-linux-muslabi64", mips64el_unknown_linux_muslabi64),
    ("hexagon-unknown-linux-musl", hexagon_unknown_linux_musl),
    ("hexagon-unknown-none-elf", hexagon_unknown_none_elf),
    ("mips-unknown-linux-uclibc", mips_unknown_linux_uclibc),
    ("mipsel-unknown-linux-uclibc", mipsel_unknown_linux_uclibc),
    ("i686-linux-android", i686_linux_android),
    ("x86_64-linux-android", x86_64_linux_android),
    ......
}
```

每个编译目标，都有一份对应的target配置，用于告诉编译器特定平台的一些特定信息，例如：

- `llvm_target` :用于指定`LLVM`（底层编译框架）如何识别和生成目标代码的格式。
- `pointer_width`:定义指针的宽度（位数）。例如`aarch64`架构的指针宽度就是64。
- `data_layout`：指定了内存中的数据如何对齐和排列。这对编译器如何处理数据结构和内存访问至关重要。
- `arch`：目标架构，让编译器能够将程序编译成指定架构的指令
- `max_atomic_width`：指定目标平台上支持的最大原子操作宽度。
- `env`：指定目标平台的环境。它通常用于描述标准库和工具链的类型。
- `linker`：指定用于目标平台的链接器。
- ......

因此在本项目中，需要将`aarch64-unknown-rtsmart`该编译目标对应的编译配置信息加入到Rust编译器的源代码中，再将当前编译目标注册到其所支持的target中，重新编译rust编译器，即可观察到新编译的rust编译器可支持该编译目标。

再在应用程序编译时配置编译目标为`aarch64-unknown-rtsmart`，即可编译出在该平台上运行的二进制文件

```toml
[build]
target = "aarch64-unknown-rtsmart"

[target.aarch64-unknown-rtsmart]
linker = "aarch64-linux-musleabi-gcc"
```

### 3. Rust标准库

Rust的标准库源代码位于Rust编译器源代码的library/std下，封装了许多系统功能，以库函数的方式提供给用户进行调用。

Rust语言的设计目标是能编写操作系统内核的系统编程语言。使用静态编译，不采用GC机制，保证开发出的应用极高性能；具备现代编程语言的高效率语法, 并在编译阶段就保证内存安全，并发安全，分支安全等安全性。 现代高级语言的标准库是语言的一个紧密的组成部分，标准库负责语言众多关键特性实现。RUST的库也是如此，但与其他采用GC方案的语言不同，其他语言编程目标是在操作系统之上运行的用户态程序，只需要考虑一种模型。RUST则需要考虑操作系统内核与用户态两种模型。C语言在解决这个问题的方法是只提供用户态的标准库，操作系统内核的库由各操作系统自行实现。 RUST的现代语言特性决定了标准库无法象C语言那样把操作系统内核及用户态程序区分成完全独立的两个部分，所以只能更细致的设计，做模块化的处理。RUST标准库体系分为三个模块：语言核心库--`core`; `alloc`库；用户态 `std`库。

- `core`库是Rust语言核心库，适用于操作系统内核及用户态，包括Rust的基础类型，基本Trait, 类型行为函数，其他函数等内容。core库是硬件架构和操作系统无关的可移植库。主要内容有编译器内置intrinsics函数，包括内存操作函数，算数函数，位操作函数，原子变量操作函数等， 这些函数通常与CPU硬件架构紧密相关，且一般需要汇编来提供最佳性能。 intrinsic函数实际上也是对CPU指令的屏蔽层。基本数据类型，包括整数类型，浮点类型，布尔类型，字符类型，单元类型，内容主要是实现运算符Trait, 类型转换Trait, 派生宏Trait等，字符类型包括对`unicode`，`ascii`的不同编码的处理。整数类型有大小端变换的处理。还有字符串、时间库、类型转换、基础派生宏等内容。
- `alloc`库主要实现需要进行动态堆内存申请的智能指针类型，集合类型及他们的行为，函数，`Trait`等内容，仅建立在`core`库模块之上。`std`会对`alloc`模块库的内容做重新的封装。`alloc`库适用于操作系统内核及用户态程序。 包括： 基本内存申请；`Allocator Trait`;` Allocator`的实现结构`Global` ，基础智能指针：`Box`,` Rc`, 动态数组内存类型: `RawVec`, `Vec` ，字符串类型：`&str`, `String` ，并发编程指针类型:` Arc` ，指针内访问类型: `Cell`, `RefCell` 还有些其他类型，一般仅在标准库内部使用
- `std`库是在操作系统支撑下运行的只适用于用户态程序的库，core库实现的内容基本在std库也有对应的实现。其他内容主要是将操作系统系统调用封装为适合rust特征的结构和Trait,包括： 1.进程，线程库 2.网络库 3.文件操作库 4.环境变量及参数 5.互斥与同步库，读写锁 6.定时器 7.输入输出的数据结构， 8.系统事件，对`epoll`,`kevent`等的封装。可以将std库看做基本常用的容器类型及操作系统封装库。

因此在我们的项目中，就是基于`core`库、`alloc`库，`libc`编写标准库中的一些功能库，具体实现设计可以参考Rust编译器中的源代码，也可以自己自由发挥，只要能提供需要的功能即可。

### 4. 分析与总结

基于上述的调研，可以得到我们当前项目的设计思路流程图

## 三、开发环境搭建

## 四、外部函数接口库

在本项目中，我们的rt-smart的`libc`就链接了如下静态库：

```rust
#[link(name = "util", kind = "static",
cfg(target_feature = "crt-static"))]
#[link(name = "rt", kind = "static",
cfg(target_feature = "crt-static"))]
#[link(name = "pthread", kind = "static",
cfg(target_feature = "crt-static"))]
#[link(name = "m", kind = "static",
cfg(target_feature = "crt-static"))]
#[link(name = "dl", kind = "static",
cfg(target_feature = "crt-static"))]
#[link(name = "c", kind = "static",
cfg(target_feature = "crt-static"))]
#[link(name = "rtthread", kind = "static",
cfg(target_feature = "crt-static"))]
#[link(name = "gcc_eh", kind = "static",
cfg(target_feature = "crt-static"))]
#[link(name = "gcc", kind = "static",
cfg(target_feature = "crt-static"))]
#[link(name = "util", cfg(not(target_feature = "crt-static")))]
#[link(name = "rt", cfg(not(target_feature = "crt-static")))]
#[link(name = "pthread", cfg(not(target_feature = "crt-static")))]
#[link(name = "m", cfg(not(target_feature = "crt-static")))]
#[link(name = "dl", cfg(not(target_feature = "crt-static")))]
#[link(name = "c", cfg(not(target_feature = "crt-static")))]
#[link(name = "rtthread", cfg(not(target_feature = "crt-static")))]
```

之后在build.rs中查找这些静态库并链接进项目即可：

```rust
println!("cargo:rustc-link-search=/opt/aarch64-smart-musleabi/aarch64-linux-musleabi/lib");
println!("cargo:rustc-link-lib=static=util");
println!("cargo:rustc-link-lib=static=rt");
println!("cargo:rustc-link-lib=static=pthread");
println!("cargo:rustc-link-lib=static=m");
println!("cargo:rustc-link-lib=static=dl");
println!("cargo:rustc-link-lib=static=c");
println!("cargo:rustc-link-lib=static=rtthread");
println!("cargo:rustc-link-lib=static=gcc_eh");
println!("cargo:rustc-link-lib=static=gcc");
// Avoid unnecessary re-building.
println!("cargo:rerun-if-changed=build.rs");
```


## 五、编译器添加编译目标

## 六、编写标准库

### 1. stdout库

### 2. stdin库

### 3. thread库

### 4. mutex库

### 5. fs库

## 七、标准库测试程序及测试结果

## 八、项目未来展望

## 九、参考资料





