# proj27 在RT-Thread Smart上支持rust语言编写的用户态程序

| 属性     | 值                   |
| -------- | -------------------- |
| 团队成员 | 熊嘉晟、毛灿、林观韬 |
| 指导老师 | 苏曙光               |
| 参赛学校 | 华中科技大学         |

## 目标描述

RT-Thread Smart（简称rt-smart）是适用于嵌入式平台的实时操作系统。

目前RT-Thread Smart的用户态应用程序只支持C/C++程序，它使用musl libc。而随着嵌入式生态的发展，我们认为在rt-smart上运行Rust语言的应用程序也是相当重要的。本项目旨在为rt-smart增加Rust语言用户程序支持。

## 预期目标

**注意：下面的内容是建议内容，不要求必须全部完成。选择本项目的同学也可与导师联系，提出自己的新想法，如导师认可，可加入预期目标**

### 第一题：Rust语言支持库(已完成)

- 编译并运行rt-smart操作系统。编译一个最小的Rust语言程序，使之能在rt-smart操作系统上运行；
- 查阅rt-smart的文档和资料，了解其中可用的系统调用。查阅rt-smart与编译器有关的文档，了解rt-smart遵守的调用约定；
- 选择一个系统调用的模块，制作一个封装和处理这部分系统调用的库。依赖于这个库，用户可以编写应用于rt-smart操作系统的应用程序，并使用里面的系统调用。请参考libtock-rs。

### 第二题：制作一个到rt-smart的Rust编译目标(已完成)

- 查阅Rust语言相关的资料，了解Rust语言目前支持哪些平台。Rust语言是否拥有面向嵌入式操作系统专门的编译目标？请举例；
- 作为一个独立的平台，rt-smart提供平台相关的开发方法。请为Rust编译器添加一个名为“aarch64-rt-smart”的编译目标。使用该目标得到的二进制程序，能直接应用到rt-smart支持的平台上；
- 请将第一题的成果视作标准库的一部分，选择一个系统调用的模块，为aarch64-rt-smart添加std标准库对应模块的代码。

### 第三题：Rust生态中的rt-smart平台(已完成)

- 许多的库实现和平台有关系，这些库通常需要特定的操作系统功能支持。比如num_cpus，它在不同平台上调用不同的系统调用，达到列出CPU核数量的功能。查阅资料，列出几个这样的库。[您可能需要浏览crates.io或lib.rs](http://xn--crates-2b6jp45f6hzoe5bfutnya307j.xn--iolib-ym6j.rs/)。
- 选择一个Rust生态中的库，为其添加代码，使之能支持rt-smart操作系统的相关功能。

### 项目目录结构

代码和文档都存储Gitlab仓库中。以下是仓库目录和文件描述： 

```plaintext
.project2210132-226009/						
│   README.md				//项目说明文件
│   技术文档.md				//技术文档
│   技术文档.pdf			    //技术文档PDF版本
├─ img/                     //技术文档图片
├─ examples/                //标准库测试程序
│	├── example1/hello		//libc和rust编译目标的测试，最小的Rust语言程序
│	├── example2/hello		//测试marco_main属性宏和stdout库的测试程序
│	├── example3/thread_test//测试thread库的测试程序
│	├── example4/mutex_test //测试mutex库的测试程序
│	├── example5/read_test  //测试stdin库的测试程序
│	└── example6/file_test  //测试fs库的测试程序
├─ libc/					//Rust在不同系统平台的外部函数接口
├─ marco_main/				//将Rust风格的main函数转换为C风格的main函数的属性宏
├─ rtsmart-std/				//基于libc开发的rtsmart平台上的标准库
│	├── src/				//源代码
│		├── api/			//封装调用libc的api
│		├── prelude/		//预引入的库
│		│   fs.rs			//fs库
│		│   lib.rs			//模块声明
│		│   malloc.rs		//内存分配器
│		│   mutex.rs		//mutex库
│		│   put.rs			//stdout库的辅助模块
│		│   stdin.rs		//stdin库
│		│   stdout.rs		//stdout库
│		│   thread.rs		//thread库
│		└── time.rs			//time库
├─ rust/					//为添加编译目标，在rust编译器源代码中修改或添加的文件
├─ video/					//标准库测试程序的演示视频
└─ worklog/					//每周的工作日志
```

- 该项目完整的开发流程记录在worklog目录下的每周的工作日志内：[worklog](https://gitlab.eduxiji.net/T202410487992548/project2210132-226009/-/tree/main/worklog)
- 该项目的技术文档位于主目录下，其内包含项目的的基本情况以及技术的运用：[技术文档](https://gitlab.eduxiji.net/T202410487992548/project2210132-226009/-/blob/main/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3.pdf)
- 所有文档均提供了markdown格式与pdf格式各一份
- 由于Rust编译器源代码过于庞大，因此该项目中Rust编译器部分按照编译器源代码的目录格式，仅包含修改过的文件或新增加的文件
- 测试程序的演示视频位于video目录下：[video](https://gitlab.eduxiji.net/T202410487992548/project2210132-226009/-/tree/main/video)

## 比赛题目分析和相关资料调研

见[技术文档](https://gitlab.eduxiji.net/T202410487992548/project2210132-226009/-/blob/main/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3.pdf)

## 系统框架设计

见[技术文档](https://gitlab.eduxiji.net/T202410487992548/project2210132-226009/-/blob/main/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3.pdf)

## 开发计划

见[worklog](https://gitlab.eduxiji.net/T202410487992548/project2210132-226009/-/tree/main/worklog)

## 比赛过程中的重要进展

见[worklog](https://gitlab.eduxiji.net/T202410487992548/project2210132-226009/-/tree/main/worklog)

## 系统测试情况

见[技术文档](https://gitlab.eduxiji.net/T202410487992548/project2210132-226009/-/blob/main/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3.pdf)

## 遇到的主要问题和解决方法

开发过程中遇到的问题主要有：

### 问题1：Rust编译器在编译目标方面的资料收集

由于Rust编译器的编译目标的资料较少，因此在为rt-smart添加编译目标时，需要查阅大量资料，包括Rust编译器的源代码，以及Rust编译器的文档。除此之外，还需查阅rt-smart和aarch64平台的相关资料，了解代码编译的目标平台的相关信息，添加到Rust编译器的编译目标中。

解决方法：查阅Rust编译器的源代码，了解Rust编译器的编译目标的相关信息，同时查阅rt-smart和aarch64平台的相关资料，了解代码编译的目标平台的相关信息，将这些信息添加到Rust编译器的编译目标中。

### 问题2：无标准库情况下编译Rust程序

无标准库的情况下编译Rust程序，无法使用Rust的main函数，同时在使用`cargo build`命令构建时，会报错找不到对应平台的标准库。

解决方法：编写属性宏将Rust风格的main函数转换为C风格的main函数，同时使用`cargo xbuild`命令，只将`alloc`库和`core`库链接到程序中，不链接标准库。

### 问题3：编写thread库和mutex库时，总会出现地址访问错误的问题

在编写thread库和mutex库时，总会出现地址访问错误的问题，导致程序无法正常运行。由于thread库和mutex库是基于libc库的封装，用到的一些结构和指针传递相对复杂，而在库函数中需要频繁进行Rust风格的指针和C风格的指针的转换，因此容易出现地址访问错误。

解决方法：在编写库函数时，反复检查指针的传递和转换，确保指针的传递和转换正确，同时在调用库函数时，确保传递的参数正确。

## 分工和协作

| 成员   | 分工情况                                                     |
| ------ | ------------------------------------------------------------ |
| 苏曙光 | 选择赛题，设计大致框架                                       |
| 熊嘉晟 | 完成框架设计、编写libc、给Rust编译器新增编译目标、编写标准库、编写技术文档和工作日志 |
| 毛灿   | 编写标准库、编写技术文档和工作日志、辅助完成细节修改         |
| 林观韬 | 编写标准库、编写技术文档和工作日志、辅助完成细节修改         |

## 提交仓库目录和文件描述

见[项目目录结构](#项目目录结构)

## 比赛收获

在参赛的过程中，我们一方面加深了对Rust语言的理解，比如`rust_target`、`core`库这些底层的建筑，或是声明宏、属性宏、生命周期、闭包等高级用法。另一方面，我们对Unix环境编程也有了更多的实践经验，例如我们在编写libc和标准库的过程中多次使用到了musl-libc中的库函数，让我们对Unix环境下这些系统库函数的使用更加熟练。除此之外，我们对rt-thread环境下的编程也了解了许多，比如线程和互斥量的使用，系统的一些底层功能等等。

在完成项目的过程中，我们查阅了许多资料，也遇到了很多难以解决的问题，比如地址访问错误，线程死锁，线程冲突等难以查明的错误，网上与本题相关的信息极少，只能通过自己的探索一步一步达成我们的目标，找出错误的原因。在这个过程中，也锻炼了我们定位bug，修复bug的能力。

更加重要的是，我们学习到了一个新的系统平台与一门新的编程语言是如何进行沟通的，通过我们的项目，成功使得Rust语言在`aarch64-unknown-rtsmart` 平台上使用成为可能，我们非常荣幸能够成为Rust语言在嵌入式平台上的生态的贡献者。